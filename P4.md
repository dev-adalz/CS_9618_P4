# Cambridge A Level Computer Science Paper 4 - Complete Study Guide

## üìã Table of Contents
1. [Exam Overview](#exam-overview)
2. [5-Hour Preparation Strategy](#5-hour-strategy)
3. [Data Structures & Algorithms (Python Implementation)](#data-structures-algorithms)
4. [Key Programming Concepts](#key-programming-concepts)
5. [Testing & Documentation](#testing-documentation)
6. [Practice Problems](#practice-problems)
7. [Exam Day Checklist](#exam-checklist)

---

## üéØ Exam Overview {#exam-overview}

**Paper 4: Practical**
- **Duration:** 2 hours 30 minutes
- **Marks:** 75 marks (25% of A Level)
- **Content:** Sections 19-20 (except low-level & declarative programming)
- **Languages:** Python, Java (console), or Visual Basic (console)
- **Requirements:** No internet/email access, evidence document submission

### What's Assessed:
- Algorithm implementation (searching, sorting, recursion)
- Abstract Data Types (Stack, Queue, Linked List, Binary Tree)
- File processing and exception handling
- Object-Oriented Programming
- Problem-solving and debugging

---

## ‚è∞ 5-Hour Intensive Preparation Strategy {#5-hour-strategy}

### Hour 1: Core Data Structures (60 min)
- **0-20 min:** Review Stack and Queue implementations
- **20-40 min:** Practice Linked List operations
- **40-60 min:** Study Binary Tree traversals

### Hour 2: Algorithms (60 min)
- **0-15 min:** Linear & Binary Search
- **15-30 min:** Bubble & Insertion Sort
- **30-45 min:** Recursion patterns
- **45-60 min:** Quick practice problems

### Hour 3: OOP & File Handling (60 min)
- **0-30 min:** Classes, inheritance, encapsulation
- **30-45 min:** File operations (read/write/append)
- **45-60 min:** Exception handling

### Hour 4: Past Paper Practice (60 min)
- Complete ONE full past paper under timed conditions
- Focus on evidence documentation

### Hour 5: Review & Weak Areas (60 min)
- Review mistakes from past paper
- Quick revision of theory concepts
- Mental preparation and exam strategy

---

## üíª COMPLETE Paper 4 Coverage - All Topics {#data-structures-algorithms}

**Paper 4 Syllabus Coverage (Sections 19-20):**
- ‚úÖ 19.1 Algorithms (Linear/Binary Search, Bubble/Insertion Sort)
- ‚úÖ 19.1 Abstract Data Types (Stack, Queue, Linked List, Binary Tree, Dictionary)
- ‚úÖ 19.2 Recursion (All types)
- ‚úÖ 20.1 Programming Paradigms (OOP, Imperative - Low-level excluded)
- ‚úÖ 20.2 File Processing (Serial, Sequential, Random access)
- ‚úÖ 20.2 Exception Handling (Try-catch-finally)

---

## üíª Data Structures & Algorithms Implementation

### 1. STACK (LIFO - Last In First Out)

```python
class Stack:
    def __init__(self):
        self.items = []
    
    def is_empty(self):
        return len(self.items) == 0
    
    def push(self, item):
        self.items.append(item)
    
    def pop(self):
        if not self.is_empty():
            return self.items.pop()
        return None
    
    def peek(self):
        if not self.is_empty():
            return self.items[-1]
        return None
    
    def size(self):
        return len(self.items)

# Example Usage
stack = Stack()
stack.push(10)
stack.push(20)
stack.push(30)
print(stack.pop())  # Output: 30
print(stack.peek())  # Output: 20
```

**Common Applications:**
- Expression evaluation
- Undo mechanisms
- Function call stack

---

### 2. QUEUE (FIFO - First In First Out)

```python
class Queue:
    def __init__(self):
        self.items = []
    
    def is_empty(self):
        return len(self.items) == 0
    
    def enqueue(self, item):
        self.items.append(item)
    
    def dequeue(self):
        if not self.is_empty():
            return self.items.pop(0)
        return None
    
    def front(self):
        if not self.is_empty():
            return self.items[0]
        return None
    
    def size(self):
        return len(self.items)

# Example Usage
queue = Queue()
queue.enqueue(10)
queue.enqueue(20)
queue.enqueue(30)
print(queue.dequeue())  # Output: 10
print(queue.front())    # Output: 20
```

**Common Applications:**
- Task scheduling
- Print queue
- Breadth-first search

---

### 3. LINKED LIST

```python
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
    
    def is_empty(self):
        return self.head is None
    
    def insert_at_beginning(self, data):
        new_node = Node(data)
        new_node.next = self.head
        self.head = new_node
    
    def insert_at_end(self, data):
        new_node = Node(data)
        if self.is_empty():
            self.head = new_node
            return
        
        current = self.head
        while current.next:
            current = current.next
        current.next = new_node
    
    def delete_node(self, key):
        current = self.head
        
        # If head node holds the key
        if current and current.data == key:
            self.head = current.next
            return
        
        # Search for the key
        prev = None
        while current and current.data != key:
            prev = current
            current = current.next
        
        # Key not found
        if current is None:
            return
        
        # Unlink the node
        prev.next = current.next
    
    def search(self, key):
        current = self.head
        while current:
            if current.data == key:
                return True
            current = current.next
        return False
    
    def display(self):
        elements = []
        current = self.head
        while current:
            elements.append(current.data)
            current = current.next
        return elements

# Example Usage
ll = LinkedList()
ll.insert_at_end(10)
ll.insert_at_end(20)
ll.insert_at_beginning(5)
print(ll.display())  # Output: [5, 10, 20]
ll.delete_node(10)
print(ll.display())  # Output: [5, 20]
```

---

### 4. BINARY TREE

```python
class TreeNode:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None

class BinaryTree:
    def __init__(self):
        self.root = None
    
    def insert(self, data):
        if self.root is None:
            self.root = TreeNode(data)
        else:
            self._insert_recursive(self.root, data)
    
    def _insert_recursive(self, node, data):
        if data < node.data:
            if node.left is None:
                node.left = TreeNode(data)
            else:
                self._insert_recursive(node.left, data)
        else:
            if node.right is None:
                node.right = TreeNode(data)
            else:
                self._insert_recursive(node.right, data)
    
    def search(self, data):
        return self._search_recursive(self.root, data)
    
    def _search_recursive(self, node, data):
        if node is None:
            return False
        if node.data == data:
            return True
        if data < node.data:
            return self._search_recursive(node.left, data)
        return self._search_recursive(node.right, data)
    
    # Inorder Traversal (Left, Root, Right)
    def inorder(self, node, result=None):
        if result is None:
            result = []
        if node:
            self.inorder(node.left, result)
            result.append(node.data)
            self.inorder(node.right, result)
        return result
    
    # Preorder Traversal (Root, Left, Right)
    def preorder(self, node, result=None):
        if result is None:
            result = []
        if node:
            result.append(node.data)
            self.preorder(node.left, result)
            self.preorder(node.right, result)
        return result
    
    # Postorder Traversal (Left, Right, Root)
    def postorder(self, node, result=None):
        if result is None:
            result = []
        if node:
            self.postorder(node.left, result)
            self.postorder(node.right, result)
            result.append(node.data)
        return result

# Example Usage
bt = BinaryTree()
bt.insert(50)
bt.insert(30)
bt.insert(70)
bt.insert(20)
bt.insert(40)
bt.insert(60)
bt.insert(80)

print("Inorder:", bt.inorder(bt.root))    # [20, 30, 40, 50, 60, 70, 80]
print("Preorder:", bt.preorder(bt.root))  # [50, 30, 20, 40, 70, 60, 80]
print("Postorder:", bt.postorder(bt.root)) # [20, 40, 30, 60, 80, 70, 50]
print("Search 40:", bt.search(40))        # True
```

---

### 5. SEARCHING ALGORITHMS

#### Linear Search
```python
def linear_search(arr, target):
    """
    Time Complexity: O(n)
    Best for: Unsorted arrays, small datasets
    """
    for i in range(len(arr)):
        if arr[i] == target:
            return i  # Return index
    return -1  # Not found

# Example
data = [64, 34, 25, 12, 22, 11, 90]
result = linear_search(data, 22)
print(f"Element found at index: {result}")  # Output: 4
```

#### Binary Search
```python
def binary_search(arr, target):
    """
    Time Complexity: O(log n)
    Requirement: Array must be sorted
    Best for: Large sorted datasets
    """
    left = 0
    right = len(arr) - 1
    
    while left <= right:
        mid = (left + right) // 2
        
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return -1

# Recursive Version
def binary_search_recursive(arr, target, left, right):
    if left > right:
        return -1
    
    mid = (left + right) // 2
    
    if arr[mid] == target:
        return mid
    elif arr[mid] < target:
        return binary_search_recursive(arr, target, mid + 1, right)
    else:
        return binary_search_recursive(arr, target, left, mid - 1)

# Example
sorted_data = [11, 12, 22, 25, 34, 64, 90]
result = binary_search(sorted_data, 25)
print(f"Element found at index: {result}")  # Output: 3
```

---

### 6. SORTING ALGORITHMS

#### Bubble Sort
```python
def bubble_sort(arr):
    """
    Time Complexity: O(n¬≤)
    Space Complexity: O(1)
    Best for: Small datasets, nearly sorted data
    """
    n = len(arr)
    
    for i in range(n):
        swapped = False
        
        # Last i elements are already in place
        for j in range(0, n - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
                swapped = True
        
        # If no swaps, array is sorted
        if not swapped:
            break
    
    return arr

# Example
data = [64, 34, 25, 12, 22, 11, 90]
sorted_data = bubble_sort(data.copy())
print("Bubble Sort:", sorted_data)
```

#### Insertion Sort
```python
def insertion_sort(arr):
    """
    Time Complexity: O(n¬≤) worst case, O(n) best case
    Space Complexity: O(1)
    Best for: Small datasets, nearly sorted data
    """
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1
        
        # Move elements greater than key one position ahead
        while j >= 0 and arr[j] > key:
            arr[j + 1] = arr[j]
            j -= 1
        
        arr[j + 1] = key
    
    return arr

# Example
data = [64, 34, 25, 12, 22, 11, 90]
sorted_data = insertion_sort(data.copy())
print("Insertion Sort:", sorted_data)
```

---

### 7. RECURSION

#### Factorial
```python
def factorial(n):
    """Calculate factorial using recursion"""
    # Base case
    if n == 0 or n == 1:
        return 1
    # Recursive case
    return n * factorial(n - 1)

print(factorial(5))  # Output: 120
```

#### Fibonacci
```python
def fibonacci(n):
    """Generate nth Fibonacci number"""
    # Base cases
    if n <= 1:
        return n
    # Recursive case
    return fibonacci(n - 1) + fibonacci(n - 2)

# Generate sequence
for i in range(10):
    print(fibonacci(i), end=" ")  # 0 1 1 2 3 5 8 13 21 34
```

#### Sum of Array (Recursive)
```python
def sum_array(arr, n):
    """Sum array elements recursively"""
    # Base case
    if n <= 0:
        return 0
    # Recursive case
    return arr[n - 1] + sum_array(arr, n - 1)

data = [1, 2, 3, 4, 5]
print(sum_array(data, len(data)))  # Output: 15
```

#### Tower of Hanoi
```python
def tower_of_hanoi(n, source, destination, auxiliary):
    """
    Solve Tower of Hanoi puzzle
    n: number of disks
    """
    if n == 1:
        print(f"Move disk 1 from {source} to {destination}")
        return
    
    # Move n-1 disks from source to auxiliary
    tower_of_hanoi(n - 1, source, auxiliary, destination)
    
    # Move remaining disk from source to destination
    print(f"Move disk {n} from {source} to {destination}")
    
    # Move n-1 disks from auxiliary to destination
    tower_of_hanoi(n - 1, auxiliary, destination, source)

# Example
tower_of_hanoi(3, 'A', 'C', 'B')
```

---

### 8. DICTIONARY (Hash Table / Associative Array)

```python
class Dictionary:
    """
    Key-Value pair storage (ADT)
    Python has built-in dict, but here's implementation concept
    """
    def __init__(self):
        self.items = {}
    
    def add(self, key, value):
        """Add or update key-value pair"""
        self.items[key] = value
    
    def get(self, key):
        """Retrieve value by key"""
        return self.items.get(key, None)
    
    def remove(self, key):
        """Remove key-value pair"""
        if key in self.items:
            del self.items[key]
            return True
        return False
    
    def contains(self, key):
        """Check if key exists"""
        return key in self.items
    
    def keys(self):
        """Return all keys"""
        return list(self.items.keys())
    
    def values(self):
        """Return all values"""
        return list(self.items.values())
    
    def size(self):
        """Return number of items"""
        return len(self.items)

# Example Usage - Student Records
student_dict = Dictionary()
student_dict.add("S001", {"name": "Alice", "grade": 85})
student_dict.add("S002", {"name": "Bob", "grade": 92})
print(student_dict.get("S001"))  # {'name': 'Alice', 'grade': 85}
print(student_dict.contains("S003"))  # False
```

**Dictionary Applications:**
- Student records (ID ‚Üí Details)
- Phone book (Name ‚Üí Number)
- Configuration settings (Key ‚Üí Value)
- Cache/Lookup tables

---

### 9. ADVANCED RECURSION PATTERNS

#### String Recursion - Count Vowels
```python
def count_vowels_recursive(text, index=0):
    """
    Count vowels in string using recursion
    Common P4 exam question!
    """
    # Base case
    if index >= len(text):
        return 0
    
    # Recursive case
    vowels = "aeiouAEIOU"
    if text[index] in vowels:
        return 1 + count_vowels_recursive(text, index + 1)
    else:
        return count_vowels_recursive(text, index + 1)

# Test
print(count_vowels_recursive("Hello World"))  # Output: 3
```

#### Palindrome Check (Recursive)
```python
def is_palindrome_recursive(text, start=0, end=None):
    """Check if string is palindrome"""
    if end is None:
        end = len(text) - 1
    
    # Base cases
    if start >= end:
        return True
    if text[start] != text[end]:
        return False
    
    # Recursive case
    return is_palindrome_recursive(text, start + 1, end - 1)

# Test
print(is_palindrome_recursive("racecar"))  # True
print(is_palindrome_recursive("hello"))    # False
```

#### Binary Search (Recursive) - IMPORTANT FOR P4
```python
def binary_search_recursive(arr, target, left, right):
    """
    Recursive binary search - frequently tested
    Time: O(log n), Space: O(log n) due to recursion stack
    """
    # Base case - not found
    if left > right:
        return -1
    
    mid = (left + right) // 2
    
    # Base case - found
    if arr[mid] == target:
        return mid
    
    # Recursive cases
    if arr[mid] > target:
        return binary_search_recursive(arr, target, left, mid - 1)
    else:
        return binary_search_recursive(arr, target, mid + 1, right)

# Test
arr = [1, 3, 5, 7, 9, 11, 13, 15]
print(binary_search_recursive(arr, 7, 0, len(arr)-1))  # Output: 3
```

#### Reverse String (Recursive)
```python
def reverse_string_recursive(text):
    """Reverse string using recursion"""
    # Base case
    if len(text) <= 1:
        return text
    
    # Recursive case
    return reverse_string_recursive(text[1:]) + text[0]

print(reverse_string_recursive("Hello"))  # "olleH"
```

#### GCD (Greatest Common Divisor) - Euclidean Algorithm
```python
def gcd_recursive(a, b):
    """
    Find GCD using Euclid's algorithm
    """
    # Base case
    if b == 0:
        return a
    
    # Recursive case
    return gcd_recursive(b, a % b)

print(gcd_recursive(48, 18))  # Output: 6
```

#### Power Function (Recursive)
```python
def power_recursive(base, exponent):
    """Calculate base^exponent recursively"""
    # Base case
    if exponent == 0:
        return 1
    
    # Recursive case
    return base * power_recursive(base, exponent - 1)

print(power_recursive(2, 5))  # Output: 32
```

#### List Sum (Recursive)
```python
def sum_list_recursive(lst):
    """Sum all elements in list"""
    # Base case
    if len(lst) == 0:
        return 0
    
    # Recursive case
    return lst[0] + sum_list_recursive(lst[1:])

print(sum_list_recursive([1, 2, 3, 4, 5]))  # Output: 15
```

---

### 10. IMPLEMENTING ADTs USING OTHER ADTs

#### Stack Using Linked List
```python
class StackNode:
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedStack:
    """Stack implemented using Linked List"""
    def __init__(self):
        self.top = None
    
    def is_empty(self):
        return self.top is None
    
    def push(self, data):
        new_node = StackNode(data)
        new_node.next = self.top
        self.top = new_node
    
    def pop(self):
        if self.is_empty():
            return None
        data = self.top.data
        self.top = self.top.next
        return data
    
    def peek(self):
        if self.is_empty():
            return None
        return self.top.data
```

#### Queue Using Two Stacks
```python
class QueueUsingStacks:
    """Queue implemented using two stacks"""
    def __init__(self):
        self.stack1 = []  # For enqueue
        self.stack2 = []  # For dequeue
    
    def enqueue(self, item):
        self.stack1.append(item)
    
    def dequeue(self):
        if not self.stack2:
            # Transfer all from stack1 to stack2
            while self.stack1:
                self.stack2.append(self.stack1.pop())
        
        if self.stack2:
            return self.stack2.pop()
        return None
```

---

### 11. CIRCULAR QUEUE (Array Implementation)

```python
class CircularQueue:
    """
    Circular Queue - Very common in P4!
    Efficient use of array space
    """
    def __init__(self, size):
        self.size = size
        self.queue = [None] * size
        self.front = 0
        self.rear = -1
        self.count = 0
    
    def is_empty(self):
        return self.count == 0
    
    def is_full(self):
        return self.count == self.size
    
    def enqueue(self, item):
        if self.is_full():
            print("Queue is full!")
            return False
        
        self.rear = (self.rear + 1) % self.size
        self.queue[self.rear] = item
        self.count += 1
        return True
    
    def dequeue(self):
        if self.is_empty():
            print("Queue is empty!")
            return None
        
        item = self.queue[self.front]
        self.queue[self.front] = None  # Optional: clear
        self.front = (self.front + 1) % self.size
        self.count -= 1
        return item
    
    def display(self):
        if self.is_empty():
            return []
        
        result = []
        i = self.front
        for _ in range(self.count):
            result.append(self.queue[i])
            i = (i + 1) % self.size
        return result

# Example Usage
cq = CircularQueue(5)
cq.enqueue(10)
cq.enqueue(20)
cq.enqueue(30)
print(cq.display())  # [10, 20, 30]
cq.dequeue()
cq.enqueue(40)
print(cq.display())  # [20, 30, 40]
```

---

### 12. PRIORITY QUEUE

```python
class PriorityQueue:
    """
    Priority Queue - Higher priority first
    """
    def __init__(self):
        self.items = []
    
    def is_empty(self):
        return len(self.items) == 0
    
    def enqueue(self, item, priority):
        """
        Add item with priority
        Lower number = higher priority
        """
        self.items.append((priority, item))
        # Keep sorted by priority
        self.items.sort(key=lambda x: x[0])
    
    def dequeue(self):
        """Remove highest priority item"""
        if not self.is_empty():
            return self.items.pop(0)[1]
        return None
    
    def peek(self):
        if not self.is_empty():
            return self.items[0][1]
        return None

# Example - Hospital Emergency Room
pq = PriorityQueue()
pq.enqueue("Patient A - Broken arm", 3)
pq.enqueue("Patient B - Heart attack", 1)  # Highest priority
pq.enqueue("Patient C - Cold", 5)
pq.enqueue("Patient D - Severe bleeding", 2)

print(pq.dequeue())  # Patient B - Heart attack
print(pq.dequeue())  # Patient D - Severe bleeding
```

---

## üéì Key Programming Concepts {#key-programming-concepts}

### Object-Oriented Programming - COMPLETE COVERAGE

```python
# 1. BASIC CLASS WITH CONSTRUCTOR
class Book:
    """Basic class demonstrating constructor and attributes"""
    def __init__(self, title, author, isbn, price):
        # Instance attributes (properties)
        self.title = title
        self.author = author
        self.isbn = isbn
        self.price = price
        self.is_available = True
    
    # Methods
    def display_info(self):
        status = "Available" if self.is_available else "Borrowed"
        return f"{self.title} by {self.author} - ${self.price} ({status})"
    
    def borrow(self):
        if self.is_available:
            self.is_available = False
            return True
        return False
    
    def return_book(self):
        self.is_available = True

# Usage
book1 = Book("Python Programming", "John Smith", "123-456", 29.99)
print(book1.display_info())
book1.borrow()


# 2. ENCAPSULATION - Private Attributes and Getters/Setters
class BankAccount:
    """Demonstrating encapsulation with private attributes"""
    def __init__(self, account_number, holder_name, initial_balance=0):
        self.__account_number = account_number  # Private
        self.__holder_name = holder_name        # Private
        self.__balance = initial_balance        # Private
        self.__transaction_history = []        # Private
    
    # GETTERS (Accessors)
    def get_account_number(self):
        return self.__account_number
    
    def get_holder_name(self):
        return self.__holder_name
    
    def get_balance(self):
        return self.__balance
    
    def get_transaction_history(self):
        return self.__transaction_history.copy()
    
    # SETTERS (Mutators) with validation
    def set_holder_name(self, name):
        if name and len(name) > 0:
            self.__holder_name = name
            return True
        return False
    
    # Business logic methods
    def deposit(self, amount):
        if amount > 0:
            self.__balance += amount
            self.__transaction_history.append(f"Deposit: +${amount}")
            return True
        return False
    
    def withdraw(self, amount):
        if 0 < amount <= self.__balance:
            self.__balance -= amount
            self.__transaction_history.append(f"Withdrawal: -${amount}")
            return True
        return False
    
    def transfer(self, amount, target_account):
        """Transfer money to another account"""
        if self.withdraw(amount):
            if target_account.deposit(amount):
                return True
            else:
                # Rollback if deposit fails
                self.deposit(amount)
        return False

# Usage
acc1 = BankAccount("001", "Alice", 1000)
acc2 = BankAccount("002", "Bob", 500)
acc1.withdraw(200)
acc1.transfer(100, acc2)
print(acc1.get_balance())  # 700
print(acc2.get_balance())  # 600


# 3. INHERITANCE - Single Inheritance
class Vehicle:
    """Parent/Base/Super class"""
    def __init__(self, make, model, year):
        self.make = make
        self.model = model
        self.year = year
        self.odometer = 0
    
    def get_info(self):
        return f"{self.year} {self.make} {self.model}"
    
    def drive(self, distance):
        self.odometer += distance
        print(f"Drove {distance} km. Total: {self.odometer} km")

class Car(Vehicle):
    """Child/Derived/Sub class"""
    def __init__(self, make, model, year, num_doors):
        super().__init__(make, model, year)  # Call parent constructor
        self.num_doors = num_doors
        self.fuel_capacity = 50
        self.fuel_level = 50
    
    def get_info(self):
        # Override parent method
        parent_info = super().get_info()
        return f"{parent_info} ({self.num_doors} doors)"
    
    def refuel(self, amount):
        """Car-specific method"""
        if self.fuel_level + amount <= self.fuel_capacity:
            self.fuel_level += amount
            return True
        return False

class Motorcycle(Vehicle):
    """Another child class"""
    def __init__(self, make, model, year, engine_cc):
        super().__init__(make, model, year)
        self.engine_cc = engine_cc
    
    def wheelie(self):
        """Motorcycle-specific method"""
        return "Performing wheelie!"

# Usage
car = Car("Toyota", "Camry", 2023, 4)
motorcycle = Motorcycle("Honda", "CBR", 2023, 1000)

print(car.get_info())  # 2023 Toyota Camry (4 doors)
car.drive(100)
car.refuel(20)

print(motorcycle.get_info())  # 2023 Honda CBR
print(motorcycle.wheelie())


# 4. POLYMORPHISM - Method Overriding
class Shape:
    """Abstract base class"""
    def __init__(self, name):
        self.name = name
    
    def area(self):
        """This method should be overridden"""
        return 0
    
    def perimeter(self):
        """This method should be overridden"""
        return 0
    
    def display(self):
        print(f"{self.name}: Area = {self.area()}, Perimeter = {self.perimeter()}")

class Rectangle(Shape):
    def __init__(self, width, height):
        super().__init__("Rectangle")
        self.width = width
        self.height = height
    
    def area(self):
        return self.width * self.height
    
    def perimeter(self):
        return 2 * (self.width + self.height)

class Circle(Shape):
    def __init__(self, radius):
        super().__init__("Circle")
        self.radius = radius
    
    def area(self):
        return 3.14159 * self.radius ** 2
    
    def perimeter(self):
        return 2 * 3.14159 * self.radius

class Triangle(Shape):
    def __init__(self, side1, side2, side3):
        super().__init__("Triangle")
        self.side1 = side1
        self.side2 = side2
        self.side3 = side3
    
    def area(self):
        # Heron's formula
        s = self.perimeter() / 2
        return (s * (s - self.side1) * (s - self.side2) * (s - self.side3)) ** 0.5
    
    def perimeter(self):
        return self.side1 + self.side2 + self.side3

# POLYMORPHIC BEHAVIOR - Same interface, different implementation
shapes = [
    Rectangle(5, 10),
    Circle(7),
    Triangle(3, 4, 5)
]

for shape in shapes:
    shape.display()  # Calls appropriate overridden method


# 5. CONTAINMENT (AGGREGATION/COMPOSITION)
class Address:
    """Component class"""
    def __init__(self, street, city, country, postal_code):
        self.street = street
        self.city = city
        self.country = country
        self.postal_code = postal_code
    
    def get_full_address(self):
        return f"{self.street}, {self.city}, {self.country} {self.postal_code}"

class Employee:
    """Class containing another class"""
    def __init__(self, emp_id, name, address):
        self.emp_id = emp_id
        self.name = name
        self.address = address  # Composition - Employee "has-a" Address
        self.salary = 0
    
    def set_salary(self, salary):
        self.salary = salary
    
    def display_info(self):
        print(f"ID: {self.emp_id}")
        print(f"Name: {self.name}")
        print(f"Address: {self.address.get_full_address()}")
        print(f"Salary: ${self.salary}")

# Usage
addr = Address("123 Main St", "New York", "USA", "10001")
emp = Employee("E001", "John Doe", addr)
emp.set_salary(75000)
emp.display_info()


# 6. CLASS VARIABLES vs INSTANCE VARIABLES
class Student:
    """Demonstrating class variables"""
    # Class variable - shared by all instances
    school_name = "Cambridge International School"
    total_students = 0
    
    def __init__(self, name, student_id):
        # Instance variables - unique to each instance
        self.name = name
        self.student_id = student_id
        self.grades = []
        
        # Modify class variable
        Student.total_students += 1
    
    def add_grade(self, grade):
        self.grades.append(grade)
    
    def get_average(self):
        if not self.grades:
            return 0
        return sum(self.grades) / len(self.grades)
    
    @classmethod
    def get_total_students(cls):
        """Class method - operates on class variables"""
        return cls.total_students
    
    @staticmethod
    def is_passing_grade(grade):
        """Static method - doesn't use instance or class variables"""
        return grade >= 50

# Usage
s1 = Student("Alice", "S001")
s2 = Student("Bob", "S002")
s1.add_grade(85)
s2.add_grade(92)

print(Student.get_total_students())  # 2
print(Student.is_passing_grade(45))  # False
print(s1.school_name)  # Cambridge International School


# 7. COMPLEX OOP EXAMPLE - Library System
class LibraryItem:
    """Base class for library items"""
    def __init__(self, item_id, title, author):
        self.__item_id = item_id
        self.__title = title
        self.__author = author
        self.__is_borrowed = False
        self.__borrower = None
    
    # Getters
    def get_item_id(self):
        return self.__item_id
    
    def get_title(self):
        return self.__title
    
    def get_author(self):
        return self.__author
    
    def is_available(self):
        return not self.__is_borrowed
    
    def get_borrower(self):
        return self.__borrower
    
    # Business methods
    def borrow(self, borrower_name):
        if not self.__is_borrowed:
            self.__is_borrowed = True
            self.__borrower = borrower_name
            return True
        return False
    
    def return_item(self):
        if self.__is_borrowed:
            self.__is_borrowed = False
            self.__borrower = None
            return True
        return False
    
    def get_info(self):
        """To be overridden by subclasses"""
        status = "Available" if self.is_available() else f"Borrowed by {self.__borrower}"
        return f"ID: {self.__item_id}, Title: {self.__title}, Author: {self.__author}, Status: {status}"

class Book(LibraryItem):
    """Book class inheriting from LibraryItem"""
    def __init__(self, item_id, title, author, isbn, pages):
        super().__init__(item_id, title, author)
        self.__isbn = isbn
        self.__pages = pages
    
    def get_isbn(self):
        return self.__isbn
    
    def get_pages(self):
        return self.__pages
    
    def get_info(self):
        base_info = super().get_info()
        return f"{base_info}, ISBN: {self.__isbn}, Pages: {self.__pages}"

class DVD(LibraryItem):
    """DVD class inheriting from LibraryItem"""
    def __init__(self, item_id, title, director, duration_mins):
        super().__init__(item_id, title, director)
        self.__duration = duration_mins
    
    def get_duration(self):
        return self.__duration
    
    def get_info(self):
        base_info = super().get_info()
        return f"{base_info}, Duration: {self.__duration} mins"

class Library:
    """Library management system"""
    def __init__(self, name):
        self.__name = name
        self.__items = []
    
    def add_item(self, item):
        """Add item to library"""
        self.__items.append(item)
    
    def find_item(self, item_id):
        """Find item by ID"""
        for item in self.__items:
            if item.get_item_id() == item_id:
                return item
        return None
    
    def borrow_item(self, item_id, borrower_name):
        """Borrow an item"""
        item = self.find_item(item_id)
        if item:
            if item.borrow(borrower_name):
                print(f"{borrower_name} borrowed: {item.get_title()}")
                return True
            else:
                print(f"Item already borrowed by {item.get_borrower()}")
        else:
            print("Item not found")
        return False
    
    def return_item(self, item_id):
        """Return an item"""
        item = self.find_item(item_id)
        if item:
            if item.return_item():
                print(f"Returned: {item.get_title()}")
                return True
            else:
                print("Item was not borrowed")
        else:
            print("Item not found")
        return False
    
    def list_available_items(self):
        """List all available items"""
        print(f"\nAvailable items in {self.__name}:")
        for item in self.__items:
            if item.is_available():
                print(item.get_info())
    
    def list_borrowed_items(self):
        """List all borrowed items"""
        print(f"\nBorrowed items from {self.__name}:")
        for item in self.__items:
            if not item.is_available():
                print(item.get_info())

# Usage Example
library = Library("City Library")

# Add items
book1 = Book("B001", "Python Programming", "John Smith", "978-123", 450)
book2 = Book("B002", "Data Structures", "Jane Doe", "978-456", 380)
dvd1 = DVD("D001", "The Matrix", "Wachowski", 136)

library.add_item(book1)
library.add_item(book2)
library.add_item(dvd1)

# Operations
library.list_available_items()
library.borrow_item("B001", "Alice")
library.borrow_item("D001", "Bob")
library.list_borrowed_items()
library.return_item("B001")
library.list_available_items()


# 8. OPERATOR OVERLOADING (Python specific)
class Vector:
    """Demonstrating operator overloading"""
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def __str__(self):
        """String representation"""
        return f"Vector({self.x}, {self.y})"
    
    def __add__(self, other):
        """Overload + operator"""
        return Vector(self.x + other.x, self.y + other.y)
    
    def __sub__(self, other):
        """Overload - operator"""
        return Vector(self.x - other.x, self.y - other.y)
    
    def __eq__(self, other):
        """Overload == operator"""
        return self.x == other.x and self.y == other.y
    
    def magnitude(self):
        """Calculate vector magnitude"""
        return (self.x ** 2 + self.y ** 2) ** 0.5

# Usage
v1 = Vector(3, 4)
v2 = Vector(1, 2)
v3 = v1 + v2  # Uses __add__
print(v3)  # Vector(4, 6)
print(v1 == v2)  # False
print(v1.magnitude())  # 5.0
```

---

### Advanced OOP - Game Character System (Common P4 Question Pattern)

```python
class Character:
    """Base character class for game"""
    def __init__(self, name, health, attack_power):
        self.__name = name
        self.__health = health
        self.__max_health = health
        self.__attack_power = attack_power
        self.__is_alive = True
        self.__level = 1
    
    # Getters
    def get_name(self):
        return self.__name
    
    def get_health(self):
        return self.__health
    
    def get_attack_power(self):
        return self.__attack_power
    
    def is_alive_status(self):
        return self.__is_alive
    
    def get_level(self):
        return self.__level
    
    # Setters
    def set_health(self, health):
        self.__health = max(0, min(health, self.__max_health))
        if self.__health == 0:
            self.__is_alive = False
    
    def set_attack_power(self, power):
        if power > 0:
            self.__attack_power = power
    
    # Methods
    def take_damage(self, damage):
        """Reduce health when damaged"""
        self.__health -= damage
        if self.__health <= 0:
            self.__health = 0
            self.__is_alive = False
            return f"{self.__name} has been defeated!"
        return f"{self.__name} took {damage} damage. Health: {self.__health}"
    
    def heal(self, amount):
        """Restore health"""
        if self.__is_alive:
            self.__health = min(self.__health + amount, self.__max_health)
            return f"{self.__name} healed {amount}. Health: {self.__health}"
        return f"{self.__name} is defeated and cannot heal"
    
    def attack(self, target):
        """Attack another character"""
        if self.__is_alive:
            return target.take_damage(self.__attack_power)
        return f"{self.__name} is defeated and cannot attack"
    
    def level_up(self):
        """Increase level and stats"""
        self.__level += 1
        self.__max_health += 20
        self.__health = self.__max_health
        self.__attack_power += 5
        return f"{self.__name} leveled up to {self.__level}!"
    
    def display_stats(self):
        """Display character stats"""
        status = "Alive" if self.__is_alive else "Defeated"
        print(f"\n--- {self.__name} ---")
        print(f"Level: {self.__level}")
        print(f"Health: {self.__health}/{self.__max_health}")
        print(f"Attack Power: {self.__attack_power}")
        print(f"Status: {status}")

class Warrior(Character):
    """Warrior class with special abilities"""
    def __init__(self, name, health, attack_power, armor):
        super().__init__(name, health, attack_power)
        self.__armor = armor
        self.__rage = 0
    
    def get_armor(self):
        return self.__armor
    
    def take_damage(self, damage):
        """Override - reduced damage due to armor"""
        reduced_damage = max(1, damage - self.__armor)
        self.__rage += 10  # Build rage when taking damage
        return super().take_damage(reduced_damage)
    
    def power_attack(self, target):
        """Special ability - costs rage"""
        if self.__rage >= 30:
            self.__rage -= 30
            damage = self.get_attack_power() * 2
            return target.take_damage(damage)
        return "Not enough rage for power attack"

class Mage(Character):
    """Mage class with magic abilities"""
    def __init__(self, name, health, attack_power, mana):
        super().__init__(name, health, attack_power)
        self.__mana = mana
        self.__max_mana = mana
    
    def get_mana(self):
        return self.__mana
    
    def cast_fireball(self, target):
        """Special spell"""
        mana_cost = 20
        if self.__mana >= mana_cost:
            self.__mana -= mana_cost
            damage = self.get_attack_power() * 1.5
            return target.take_damage(int(damage))
        return "Not enough mana"
    
    def meditate(self):
        """Restore mana"""
        self.__mana = min(self.__mana + 30, self.__max_mana)
        return f"Mana restored to {self.__mana}"

class Healer(Character):
    """Healer class with healing abilities"""
    def __init__(self, name, health, attack_power, healing_power):
        super().__init__(name, health, attack_power)
        self.__healing_power = healing_power
    
    def heal_ally(self, target):
        """Heal another character"""
        return target.heal(self.__healing_power)
    
    def resurrect(self, target):
        """Bring character back to life (if recently defeated)"""
        if not target.is_alive_status():
            target.set_health(target.get_health() + 50)
            return f"{target.get_name()} has been resurrected!"
        return f"{target.get_name()} is already alive"

# Game Usage Example
warrior = Warrior("Thor", 150, 25, 10)
mage = Mage("Gandalf", 100, 30, 100)
healer = Healer("Mercy", 80, 15, 40)

# Battle simulation
warrior.display_stats()
mage.display_stats()

print("\n--- Battle Start ---")
print(warrior.attack(mage))
print(mage.cast_fireball(warrior))
print(healer.heal_ally(warrior))
print(warrior.power_attack(mage))

warrior.level_up()
warrior.display_stats()
```

---

## üéì Key Programming Concepts {#key-programming-concepts}

```python
# ENCAPSULATION
class BankAccount:
    def __init__(self, account_number, balance=0):
        self.__account_number = account_number  # Private
        self.__balance = balance  # Private
    
    # Getter
    def get_balance(self):
        return self.__balance
    
    # Setter with validation
    def deposit(self, amount):
        if amount > 0:
            self.__balance += amount
            return True
        return False
    
    def withdraw(self, amount):
        if 0 < amount <= self.__balance:
            self.__balance -= amount
            return True
        return False

# INHERITANCE
class SavingsAccount(BankAccount):
    def __init__(self, account_number, balance=0, interest_rate=0.02):
        super().__init__(account_number, balance)
        self.interest_rate = interest_rate
    
    def add_interest(self):
        interest = self.get_balance() * self.interest_rate
        self.deposit(interest)

# POLYMORPHISM
class Shape:
    def area(self):
        pass

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height
    
    def area(self):
        return self.width * self.height

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius
    
    def area(self):
        return 3.14159 * self.radius ** 2

# Example Usage
shapes = [Rectangle(5, 10), Circle(7)]
for shape in shapes:
    print(f"Area: {shape.area()}")
```

---

### Advanced File Processing Operations

```python
# SERIAL FILE - Records stored sequentially, no order
def write_serial_file(filename, records):
    """Write records to serial file"""
    try:
        with open(filename, 'w') as f:
            for record in records:
                f.write(','.join(map(str, record)) + '\n')
        return True
    except IOError as e:
        print(f"Error: {e}")
        return False

def read_serial_file(filename):
    """Read all records from serial file"""
    try:
        records = []
        with open(filename, 'r') as f:
            for line in f:
                record = line.strip().split(',')
                records.append(record)
        return records
    except FileNotFoundError:
        print(f"File {filename} not found")
        return []

# SEQUENTIAL FILE - Records in order by key field
def write_sequential_file(filename, records, key_index=0):
    """
    Write records in order by key field
    key_index: which field to sort by
    """
    try:
        # Sort records by key
        sorted_records = sorted(records, key=lambda x: x[key_index])
        with open(filename, 'w') as f:
            for record in sorted_records:
                f.write(','.join(map(str, record)) + '\n')
        return True
    except IOError as e:
        print(f"Error: {e}")
        return False

def search_sequential_file(filename, key, key_index=0):
    """
    Search for record in sequential file
    More efficient than serial - can stop when key > target
    """
    try:
        with open(filename, 'r') as f:
            for line in f:
                record = line.strip().split(',')
                if record[key_index] == key:
                    return record
                # Can stop if we pass the key (file is sorted)
                if record[key_index] > key:
                    return None
        return None
    except FileNotFoundError:
        return None

# RANDOM ACCESS FILE - Direct access by position
def create_random_access_file(filename, num_records, record_size):
    """
    Create file with fixed-size records
    record_size: number of bytes per record
    """
    try:
        with open(filename, 'wb') as f:
            empty_record = b' ' * record_size
            for _ in range(num_records):
                f.write(empty_record)
        return True
    except IOError:
        return False

def write_random_record(filename, position, data, record_size):
    """
    Write data at specific position
    position: record number (0-indexed)
    """
    try:
        with open(filename, 'r+b') as f:
            f.seek(position * record_size)
            # Pad or truncate to record_size
            data_bytes = data.encode('utf-8')[:record_size]
            data_bytes += b' ' * (record_size - len(data_bytes))
            f.write(data_bytes)
        return True
    except IOError:
        return False

def read_random_record(filename, position, record_size):
    """Read record from specific position"""
    try:
        with open(filename, 'rb') as f:
            f.seek(position * record_size)
            data = f.read(record_size)
            return data.decode('utf-8').strip()
    except IOError:
        return None

# HASHING FOR RANDOM FILE ACCESS
def hash_function(key, table_size):
    """
    Simple hash function for random file access
    Common P4 question!
    """
    # Method 1: Modulo division
    return key % table_size

def hash_function_folding(key_str, table_size):
    """
    Hash using folding method
    """
    total = sum(ord(char) for char in key_str)
    return total % table_size

def hash_function_mid_square(key, table_size):
    """
    Mid-square method
    """
    squared = key * key
    # Extract middle digits
    squared_str = str(squared)
    mid = len(squared_str) // 2
    # Extract appropriate digits
    hash_val = int(squared_str[mid-1:mid+1]) if len(squared_str) > 2 else squared
    return hash_val % table_size

# FILE OPERATIONS WITH HASHING
class HashFileStorage:
    """
    Store records using hash table in file
    """
    def __init__(self, filename, table_size, record_size):
        self.filename = filename
        self.table_size = table_size
        self.record_size = record_size
        # Initialize file if doesn't exist
        try:
            open(filename, 'r')
        except FileNotFoundError:
            create_random_access_file(filename, table_size, record_size)
    
    def insert(self, key, data):
        """Insert record using hash"""
        position = hash_function(key, self.table_size)
        
        # Linear probing for collision resolution
        original_pos = position
        while True:
            existing = read_random_record(self.filename, position, self.record_size)
            
            if not existing or existing.strip() == '':
                # Empty slot found
                write_random_record(self.filename, position, data, self.record_size)
                return position
            
            # Collision - try next position
            position = (position + 1) % self.table_size
            
            # Table full
            if position == original_pos:
                return -1
    
    def search(self, key, key_data):
        """Search for record by key"""
        position = hash_function(key, self.table_size)
        original_pos = position
        
        while True:
            data = read_random_record(self.filename, position, self.record_size)
            
            if not data or data.strip() == '':
                return None
            
            if data.startswith(key_data):
                return data
            
            position = (position + 1) % self.table_size
            
            if position == original_pos:
                return None

# Example Usage
# Serial file
students = [
    ['Alice', '85', '90'],
    ['Bob', '78', '82'],
    ['Charlie', '92', '88']
]
write_serial_file('students_serial.txt', students)
all_students = read_serial_file('students_serial.txt')

# Sequential file (sorted by name)
write_sequential_file('students_seq.txt', students, key_index=0)
result = search_sequential_file('students_seq.txt', 'Bob', key_index=0)

# Random access with hashing
storage = HashFileStorage('hash_file.dat', 100, 50)
storage.insert(12345, 'John Doe,85,90')
result = storage.search(12345, 'John')
```

---

### Complete Exception Handling Patterns

```python
# MULTIPLE EXCEPTION TYPES
def safe_file_read(filename):
    """Handle multiple exception types"""
    try:
        with open(filename, 'r') as f:
            data = f.read()
            # Process data
            numbers = [int(x) for x in data.split(',')]
            return numbers
    
    except FileNotFoundError:
        print(f"Error: File '{filename}' not found")
        return None
    
    except PermissionError:
        print(f"Error: Permission denied for '{filename}'")
        return None
    
    except ValueError as e:
        print(f"Error: Invalid data format - {e}")
        return None
    
    except IOError as e:
        print(f"Error: IO error occurred - {e}")
        return None
    
    except Exception as e:
        print(f"Error: Unexpected error - {e}")
        return None
    
    finally:
        print("File operation completed")

# CUSTOM EXCEPTIONS FOR VALIDATION
class InvalidAgeError(Exception):
    """Custom exception for age validation"""
    pass

class InvalidGradeError(Exception):
    """Custom exception for grade validation"""
    pass

class Student:
    def __init__(self, name, age, grade):
        self.name = name
        self.set_age(age)
        self.set_grade(grade)
    
    def set_age(self, age):
        """Validate and set age"""
        try:
            if age < 0:
                raise InvalidAgeError("Age cannot be negative")
            if age > 150:
                raise InvalidAgeError("Age is unrealistic")
            self.age = age
        except InvalidAgeError as e:
            print(f"Age Error: {e}")
            self.age = 0  # Default
    
    def set_grade(self, grade):
        """Validate and set grade"""
        try:
            if grade < 0 or grade > 100:
                raise InvalidGradeError("Grade must be between 0 and 100")
            self.grade = grade
        except InvalidGradeError as e:
            print(f"Grade Error: {e}")
            self.grade = 0  # Default

# EXCEPTION HANDLING IN DATA STRUCTURES
class SafeStack:
    """Stack with exception handling"""
    def __init__(self, max_size=100):
        self.items = []
        self.max_size = max_size
    
    def push(self, item):
        try:
            if len(self.items) >= self.max_size:
                raise OverflowError("Stack is full")
            self.items.append(item)
            return True
        except OverflowError as e:
            print(f"Error: {e}")
            return False
    
    def pop(self):
        try:
            if len(self.items) == 0:
                raise IndexError("Stack is empty")
            return self.items.pop()
        except IndexError as e:
            print(f"Error: {e}")
            return None

# EXCEPTION HANDLING WITH FILES AND OOP
class StudentDatabase:
    """Database with comprehensive exception handling"""
    def __init__(self, filename):
        self.filename = filename
        self.students = []
        self.load_from_file()
    
    def load_from_file(self):
        """Load with exception handling"""
        try:
            with open(self.filename, 'r') as f:
                for line in f:
                    parts = line.strip().split(',')
                    if len(parts) != 3:
                        raise ValueError(f"Invalid record: {line}")
                    
                    name, age, grade = parts
                    student = Student(name, int(age), float(grade))
                    self.students.append(student)
            
            print(f"Loaded {len(self.students)} students")
        
        except FileNotFoundError:
            print(f"File not found. Creating new database.")
            self.students = []
        
        except ValueError as e:
            print(f"Data format error: {e}")
            self.students = []
        
        except Exception as e:
            print(f"Unexpected error: {e}")
            self.students = []
    
    def save_to_file(self):
        """Save with exception handling"""
        try:
            with open(self.filename, 'w') as f:
                for student in self.students:
                    f.write(f"{student.name},{student.age},{student.grade}\n")
            return True
        
        except PermissionError:
            print("Error: No permission to write file")
            return False
        
        except IOError as e:
            print(f"Error saving: {e}")
            return False
    
    def add_student(self, name, age, grade):
        """Add student with validation"""
        try:
            student = Student(name, age, grade)
            self.students.append(student)
            self.save_to_file()
            return True
        except Exception as e:
            print(f"Error adding student: {e}")
            return False

# NESTED TRY-EXCEPT
def process_student_data(filename):
    """Nested exception handling"""
    try:
        # Outer try - file operations
        with open(filename, 'r') as f:
            for line_num, line in enumerate(f, 1):
                try:
                    # Inner try - data processing
                    name, grade = line.strip().split(',')
                    grade = float(grade)
                    
                    if grade < 0 or grade > 100:
                        raise ValueError("Invalid grade range")
                    
                    print(f"Processed: {name} - {grade}")
                
                except ValueError as e:
                    print(f"Line {line_num} error: {e}")
                    continue  # Skip this line, continue with next
                
                except Exception as e:
                    print(f"Line {line_num} unexpected error: {e}")
                    continue
    
    except FileNotFoundError:
        print("File not found")
    except Exception as e:
        print(f"File error: {e}")

# RE-RAISING EXCEPTIONS
def validate_and_process(data):
    """Re-raise after logging"""
    try:
        result = int(data)
        if result < 0:
            raise ValueError("Negative value")
        return result
    except ValueError as e:
        print(f"Validation failed: {e}")
        raise  # Re-raise for caller to handle
    except Exception as e:
        print(f"Unexpected error: {e}")
        raise

# Example Usage
try:
    value = validate_and_process("-5")
except ValueError:
    print("Caller handled the re-raised exception")
```

---

## üéì Key Programming Concepts {#key-programming-concepts}

```python
# TEXT FILE OPERATIONS
def write_to_file(filename, data):
    """Write data to file"""
    try:
        with open(filename, 'w') as file:
            file.write(data)
        return True
    except IOError as e:
        print(f"Error writing to file: {e}")
        return False

def read_from_file(filename):
    """Read data from file"""
    try:
        with open(filename, 'r') as file:
            return file.read()
    except FileNotFoundError:
        print(f"File {filename} not found")
        return None
    except IOError as e:
        print(f"Error reading file: {e}")
        return None

def append_to_file(filename, data):
    """Append data to file"""
    try:
        with open(filename, 'a') as file:
            file.write(data)
        return True
    except IOError as e:
        print(f"Error appending to file: {e}")
        return False

# CSV FILE OPERATIONS
def write_csv(filename, data):
    """Write list of records to CSV"""
    try:
        with open(filename, 'w') as file:
            for record in data:
                line = ','.join(map(str, record)) + '\n'
                file.write(line)
        return True
    except IOError as e:
        print(f"Error writing CSV: {e}")
        return False

def read_csv(filename):
    """Read CSV file into list of lists"""
    try:
        data = []
        with open(filename, 'r') as file:
            for line in file:
                record = line.strip().split(',')
                data.append(record)
        return data
    except FileNotFoundError:
        print(f"File {filename} not found")
        return []
    except IOError as e:
        print(f"Error reading CSV: {e}")
        return []

# BINARY FILE OPERATIONS (for random access)
import struct

def write_binary_record(filename, position, data):
    """Write record at specific position"""
    try:
        with open(filename, 'r+b') as file:
            file.seek(position * struct.calcsize('i'))
            file.write(struct.pack('i', data))
        return True
    except IOError as e:
        print(f"Error writing binary: {e}")
        return False

# Example Usage
write_to_file('test.txt', 'Hello, World!')
content = read_from_file('test.txt')
print(content)

students = [['John', 85], ['Alice', 92], ['Bob', 78]]
write_csv('students.csv', students)
data = read_csv('students.csv')
print(data)
```

---

### Exception Handling

```python
def divide_numbers(a, b):
    """Safe division with exception handling"""
    try:
        result = a / b
        return result
    except ZeroDivisionError:
        print("Error: Cannot divide by zero")
        return None
    except TypeError:
        print("Error: Invalid data type")
        return None
    except Exception as e:
        print(f"Unexpected error: {e}")
        return None
    finally:
        print("Division operation completed")

def read_integer_input():
    """Read integer with validation"""
    while True:
        try:
            value = int(input("Enter an integer: "))
            return value
        except ValueError:
            print("Invalid input. Please enter a valid integer.")
        except KeyboardInterrupt:
            print("\nOperation cancelled")
            return None

def access_list_element(lst, index):
    """Safe list access"""
    try:
        return lst[index]
    except IndexError:
        print(f"Error: Index {index} out of range")
        return None
    except TypeError:
        print("Error: Invalid index type")
        return None

# Custom Exception
class InvalidAgeError(Exception):
    pass

def validate_age(age):
    """Validate age with custom exception"""
    try:
        if age < 0:
            raise InvalidAgeError("Age cannot be negative")
        elif age > 150:
            raise InvalidAgeError("Age is too high")
        return True
    except InvalidAgeError as e:
        print(f"Validation error: {e}")
        return False

# Example Usage
print(divide_numbers(10, 2))   # Output: 5.0
print(divide_numbers(10, 0))   # Error handling
validate_age(-5)               # Custom exception
```

---

## ‚úÖ Testing & Documentation {#testing-documentation}

### Test Data Types

```python
def test_function(func, test_cases):
    """
    Comprehensive testing framework
    """
    print(f"\nTesting: {func.__name__}")
    print("=" * 50)
    
    passed = 0
    failed = 0
    
    for i, (input_data, expected) in enumerate(test_cases, 1):
        try:
            result = func(*input_data) if isinstance(input_data, tuple) else func(input_data)
            status = "‚úì PASS" if result == expected else "‚úó FAIL"
            
            if result == expected:
                passed += 1
            else:
                failed += 1
            
            print(f"Test {i}: {status}")
            print(f"  Input: {input_data}")
            print(f"  Expected: {expected}")
            print(f"  Got: {result}")
            
        except Exception as e:
            failed += 1
            print(f"Test {i}: ‚úó ERROR")
            print(f"  Input: {input_data}")
            print(f"  Error: {e}")
        
        print()
    
    print(f"Summary: {passed} passed, {failed} failed")
    print("=" * 50)

# Example: Testing a search function
def search_example(arr, target):
    return linear_search(arr, target)

test_cases = [
    # (input, expected_output)
    (([1, 2, 3, 4, 5], 3), 2),     # Normal: middle element
    (([1, 2, 3, 4, 5], 1), 0),     # Boundary: first element
    (([1, 2, 3, 4, 5], 5), 4),     # Boundary: last element
    (([1, 2, 3, 4, 5], 6), -1),    # Abnormal: not found
    (([], 3), -1),                  # Extreme: empty array
    (([1], 1), 0),                  # Extreme: single element found
    (([1], 2), -1),                 # Extreme: single element not found
]

test_function(search_example, test_cases)
```

### Evidence Document Template

```
TASK 1: [Description]
----------------------------------------
CODE:
[Paste your code here with line numbers]

TEST PLAN:
Test | Input Data       | Expected Output | Test Type
-----|------------------|-----------------|----------
1    | [5, 3, 8, 1]    | [1, 3, 5, 8]   | Normal
2    | []              | []              | Boundary
3    | [1]             | [1]             | Boundary
4    | [-5, 3, -2]     | [-5, -2, 3]    | Normal

TEST RESULTS:
[Screenshots showing program output for each test]

Test 1: PASSED ‚úì
Test 2: PASSED ‚úì
Test 3: PASSED ‚úì
Test 4: PASSED ‚úì

EVALUATION:
- Algorithm works correctly for all test cases
- Handles edge cases (empty array, single element)
- Time complexity: O(n¬≤)
```

---

## üß™ Practice Problems {#practice-problems}

### Problem 1: Student Grade Management
```python
"""
Create a system to manage student grades:
1. Add student with name and grades (list)
2. Calculate average grade
3. Find highest/lowest scoring student
4. Save/load from file
"""

class Student:
    def __init__(self, name, grades):
        self.name = name
        self.grades = grades
    
    def average(self):
        if not self.grades:
            return 0
        return sum(self.grades) / len(self.grades)

class GradeManager:
    def __init__(self):
        self.students = []
    
    def add_student(self, name, grades):
        self.students.append(Student(name, grades))
    
    def highest_scorer(self):
        if not self.students:
            return None
        return max(self.students, key=lambda s: s.average())
    
    def save_to_file(self, filename):
        try:
            with open(filename, 'w') as f:
                for student in self.students:
                    grades_str = ','.join(map(str, student.grades))
                    f.write(f"{student.name}:{grades_str}\n")
            return True
        except IOError:
            return False
    
    def load_from_file(self, filename):
        try:
            self.students = []
            with open(filename, 'r') as f:
                for line in f:
                    name, grades_str = line.strip().split(':')
                    grades = list(map(int, grades_str.split(',')))
                    self.add_student(name, grades)
            return True
        except (IOError, ValueError):
            return False

# Test the system
manager = GradeManager()
manager.add_student("Alice", [85, 90, 88])
manager.add_student("Bob", [75, 82, 79])
manager.save_to_file("grades.txt")
```

### Problem 2: Inventory System with Stack
```python
"""
Implement an inventory system using a stack:
- Add items (push)
- Remove last item (pop)
- View most recent item (peek)
- Undo last operation
"""

class Inventory:
    def __init__(self):
        self.items = Stack()
        self.history = Stack()
    
    def add_item(self, item):
        self.items.push(item)
        self.history.push(("ADD", item))
    
    def remove_item(self):
        if not self.items.is_empty():
            item = self.items.pop()
            self.history.push(("REMOVE", item))
            return item
        return None
    
    def undo(self):
        if not self.history.is_empty():
            action, item = self.history.pop()
            if action == "ADD":
                self.items.pop()
            else:  # REMOVE
                self.items.push(item)
    
    def view_latest(self):
        return self.items.peek()
```

### Problem 3: Binary Tree Operations (EXAM-STYLE)
```python
"""
Task: Implement a binary search tree with:
- Insert operation
- Three traversal methods (inorder, preorder, postorder)
- Search operation
- Count nodes
- Find maximum value
"""

class TreeNode:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None

class BinarySearchTree:
    def __init__(self):
        self.root = None
    
    def insert(self, data):
        """Insert node into BST"""
        if self.root is None:
            self.root = TreeNode(data)
        else:
            self._insert_recursive(self.root, data)
    
    def _insert_recursive(self, node, data):
        if data < node.data:
            if node.left is None:
                node.left = TreeNode(data)
            else:
                self._insert_recursive(node.left, data)
        else:
            if node.right is None:
                node.right = TreeNode(data)
            else:
                self._insert_recursive(node.right, data)
    
    def inorder_traversal(self):
        """Left-Root-Right"""
        result = []
        self._inorder_recursive(self.root, result)
        return result
    
    def _inorder_recursive(self, node, result):
        if node:
            self._inorder_recursive(node.left, result)
            result.append(node.data)
            self._inorder_recursive(node.right, result)
    
    def preorder_traversal(self):
        """Root-Left-Right"""
        result = []
        self._preorder_recursive(self.root, result)
        return result
    
    def _preorder_recursive(self, node, result):
        if node:
            result.append(node.data)
            self._preorder_recursive(node.left, result)
            self._preorder_recursive(node.right, result)
    
    def postorder_traversal(self):
        """Left-Right-Root"""
        result = []
        self._postorder_recursive(self.root, result)
        return result
    
    def _postorder_recursive(self, node, result):
        if node:
            self._postorder_recursive(node.left, result)
            self._postorder_recursive(node.right, result)
            result.append(node.data)
    
    def search(self, data):
        """Search for value in BST"""
        return self._search_recursive(self.root, data)
    
    def _search_recursive(self, node, data):
        if node is None:
            return False
        if node.data == data:
            return True
        if data < node.data:
            return self._search_recursive(node.left, data)
        return self._search_recursive(node.right, data)
    
    def count_nodes(self):
        """Count total nodes"""
        return self._count_recursive(self.root)
    
    def _count_recursive(self, node):
        if node is None:
            return 0
        return 1 + self._count_recursive(node.left) + self._count_recursive(node.right)
    
    def find_max(self):
        """Find maximum value"""
        if self.root is None:
            return None
        current = self.root
        while current.right:
            current = current.right
        return current.data
    
    def find_min(self):
        """Find minimum value"""
        if self.root is None:
            return None
        current = self.root
        while current.left:
            current = current.left
        return current.data

# Test with evidence
bst = BinarySearchTree()
values = [50, 30, 70, 20, 40, 60, 80]
for val in values:
    bst.insert(val)

print("Inorder:", bst.inorder_traversal())
print("Preorder:", bst.preorder_traversal())
print("Postorder:", bst.postorder_traversal())
print("Search 40:", bst.search(40))
print("Count nodes:", bst.count_nodes())
print("Max value:", bst.find_max())
```

### Problem 4: Student Management with Files (EXAM-STYLE)
```python
"""
Task: Create a student management system that:
- Stores student records (ID, Name, Grades)
- Saves to CSV file
- Loads from CSV file
- Calculates statistics (average, highest)
- Exception handling for file operations
"""

class StudentRecord:
    def __init__(self, student_id, name, grades):
        self.student_id = student_id
        self.name = name
        self.grades = grades  # List of grades
    
    def get_average(self):
        if not self.grades:
            return 0
        return sum(self.grades) / len(self.grades)
    
    def to_csv_line(self):
        """Convert to CSV format"""
        grades_str = ';'.join(map(str, self.grades))
        return f"{self.student_id},{self.name},{grades_str}"
    
    @staticmethod
    def from_csv_line(line):
        """Create object from CSV line"""
        parts = line.strip().split(',')
        student_id = parts[0]
        name = parts[1]
        grades = [int(g) for g in parts[2].split(';')]
        return StudentRecord(student_id, name, grades)

class StudentManagement:
    def __init__(self, filename):
        self.filename = filename
        self.students = []
    
    def add_student(self, student):
        """Add student to system"""
        self.students.append(student)
    
    def find_student(self, student_id):
        """Find student by ID"""
        for student in self.students:
            if student.student_id == student_id:
                return student
        return None
    
    def get_class_average(self):
        """Calculate overall average"""
        if not self.students:
            return 0
        total = sum(s.get_average() for s in self.students)
        return total / len(self.students)
    
    def get_highest_scorer(self):
        """Find student with highest average"""
        if not self.students:
            return None
        return max(self.students, key=lambda s: s.get_average())
    
    def save_to_file(self):
        """Save all students to file"""
        try:
            with open(self.filename, 'w') as f:
                for student in self.students:
                    f.write(student.to_csv_line() + '\n')
            print(f"Data saved to {self.filename}")
            return True
        except IOError as e:
            print(f"Error saving file: {e}")
            return False
    
    def load_from_file(self):
        """Load students from file"""
        try:
            self.students = []
            with open(self.filename, 'r') as f:
                for line in f:
                    if line.strip():
                        student = StudentRecord.from_csv_line(line)
                        self.students.append(student)
            print(f"Loaded {len(self.students)} students")
            return True
        except FileNotFoundError:
            print(f"File {self.filename} not found")
            return False
        except (ValueError, IndexError) as e:
            print(f"Error parsing file: {e}")
            return False
        except IOError as e:
            print(f"Error reading file: {e}")
            return False
    
    def display_all_students(self):
        """Display all student information"""
        print("\n--- All Students ---")
        for student in self.students:
            avg = student.get_average()
            print(f"ID: {student.student_id}, Name: {student.name}, Average: {avg:.2f}")

# Test program
system = StudentManagement('students.csv')

# Add students
system.add_student(StudentRecord('S001', 'Alice', [85, 90, 88]))
system.add_student(StudentRecord('S002', 'Bob', [75, 82, 79]))
system.add_student(StudentRecord('S003', 'Charlie', [92, 95, 93]))

# Save to file
system.save_to_file()

# Display statistics
system.display_all_students()
print(f"\nClass Average: {system.get_class_average():.2f}")
highest = system.get_highest_scorer()
print(f"Highest Scorer: {highest.name} ({highest.get_average():.2f})")

# Test loading
new_system = StudentManagement('students.csv')
new_system.load_from_file()
new_system.display_all_students()
```

### Problem 5: Queue-based Task Scheduler (EXAM-STYLE)
```python
"""
Implement a task scheduler using queue:
- Add task to queue
- Process next task
- Priority tasks (use separate queue)
"""

class Task:
    def __init__(self, name, priority=False):
        self.name = name
        self.priority = priority

class TaskScheduler:
    def __init__(self):
        self.normal_queue = Queue()
        self.priority_queue = Queue()
    
    def add_task(self, task):
        if task.priority:
            self.priority_queue.enqueue(task)
        else:
            self.normal_queue.enqueue(task)
    
    def process_next(self):
        # Process priority first
        if not self.priority_queue.is_empty():
            return self.priority_queue.dequeue()
        elif not self.normal_queue.is_empty():
            return self.normal_queue.dequeue()
        return None
    
    def pending_tasks(self):
        return (self.priority_queue.size() + 
                self.normal_queue.size())
```

---

## üìù Exam Day Checklist {#exam-checklist}

### Before the Exam
- [ ] Check you have the correct programming language installed
- [ ] Verify no internet/email access on exam computer
- [ ] Have evidence.doc template ready
- [ ] Know how to copy code and take screenshots
- [ ] Practice file naming conventions

### During the Exam (Time Management)
- **0-15 min:** Read all tasks, plan approach
- **15-120 min:** Code Task 1 (45 min) ‚Üí Task 2 (45 min) ‚Üí Task 3 (15 min)
- **120-135 min:** Testing all tasks
- **135-145 min:** Documentation in evidence.doc
- **145-150 min:** Final review and save

### For Each Task
1. **Read carefully** - Understand requirements
2. **Plan** - Pseudocode or flowchart (quick)
3. **Code** - Write clean, commented code
4. **Test** - Normal, boundary, extreme cases
5. **Document** - Copy code + screenshots to evidence.doc
6. **Save** - Use exact filename specified

### Common Mistakes to Avoid
- ‚ùå Not saving work regularly
- ‚ùå Forgetting to paste code in evidence document
- ‚ùå Using wrong programming language
- ‚ùå Not testing with all required test data
- ‚ùå Poor variable names
- ‚ùå Missing comments
- ‚ùå Not handling exceptions
- ‚ùå Incorrect file operations (read/write modes)

### Quick Reference - Python Syntax

```python
# File Operations
with open('file.txt', 'r') as f:  # Read
with open('file.txt', 'w') as f:  # Write (overwrite)
with open('file.txt', 'a') as f:  # Append

# Exception Handling
try:
    # code
except SpecificError:
    # handle
finally:
    # cleanup

# Classes
class MyClass:
    def __init__(self, param):
        self.attribute = param
    
    def method(self):
        pass

# Inheritance
class Child(Parent):
    def __init__(self):
        super().__init__()
```

---

## üéØ Final Tips for 100% Success

### Conceptual Understanding
1. **Know WHY, not just HOW** - Understand when to use each data structure
2. **Time Complexity** - Be aware of Big O notation
3. **Space Complexity** - Consider memory usage

### Coding Best Practices
1. **Meaningful names:** `student_count` not `x`
2. **Comments:** Explain complex logic
3. **Modular code:** Break into functions
4. **Error handling:** Always use try-except for file operations
5. **Test thoroughly:** Edge cases matter!

### Evidence Document
- **Clear headings** for each task
- **Formatted code** with line numbers
- **All test cases** documented
- **Screenshots** showing output
- **Brief evaluation** of solution
